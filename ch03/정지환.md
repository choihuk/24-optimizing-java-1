# CH3

### 3.2 메모리

- 초기에는 많은 명령어를 처리할 수 있도록 클록 속도를 높히는데 트랜지스터를 썼다.
- 프로세서 코어의 데이터 수요를 메인 메모리가 따라오지 못하는 문제 발생

3.2.1 메모리 캐시

- CPU 캐시 고안. 레지스터보다는 느리지만 메인 메모리보다는 빠르다.
- 자주 액세스하는 메모리 위치를 CPU 캐시에 보관함으로서 메인 메모리를 재참조 하지 않을 수 이다.
- 프라이빗 캐시 L1, L2가 있고 L3는 전체 코어가 공유한다.

문제점

- 프로세서 처리율은 개선됐지만, 메모리에 있는 데이터를 어떻게 캐시로 가져오고, 캐시 데이터를 어떻게 메모리에 다시 써야 할지 결정해야했다.
- 캐시 일관성 프로토콜이라는 방법으로 해결

노스브리지

- CPU, 램, 바이오스 롬, 그래픽 카드 사이의 통신을 담당
- 프로세스가 처음 나왔을 때는 매번 캐시 연산 결과를 바로 메모리에 기록(동시 기록)
- 하지만 이는 메모리 대역폭을 너무 많이 소모해, 이후 후기록 방식으로 변경
- 캐시 블록을 교체해도 프로세서가 변경된 캐시 블록만 메모리에 기록해 메인 메모리로 되돌아가는 트래픽이 감소한다.
- 최대 전송률은 다음 인자에 따라 달라진다.
    - 메모리 클록 주파수
    - 메모리 버스폭(보통 64비트)
    - 인터페이스 개수(요즘 대부분 2개)

### 3.3 최신 프로세서의 특성

- 변환 색인 버퍼(TLB)
    - 가상 메모리 주소를 물리 메로리 주소로 매핑하는 페이지 테이블의 캐시 역할
    - 가상 주소를 참조해 물리 주소에 액세스 하는 빈번한 작업 속도가 매우 빨라진다.
    - TLB가 없다면 L1 캐시에 페이지 테이블이 있어도 가상 주소 룩업에 16사이클이 걸린다.
    - JVM TLB와 혼동을 주의하자
  
- 분기 예측과 추측 실행
    - 분기 예측은 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지한다.
    - 최근의 프로세서는 CPU 1사이클도 여러 개별 단계로 나누어 실행하여 여러 명령이 동시 실행 중이다.
    - 이런 모델에서는 조건문을 다 평가하기 전까지 분기 이후 다음 명령을 알 수 없어 프로세서는 여러 사이클 동안 멎게 된다.
    - 따라서 가장 발생 가능성이 큰 브랜치를 미리 결정하여, 추측 결과를 바탕으로 파이프 라인을 채운다
    - 추측이 맞으면 CPU는 다음 작업 진행, 틀리면 파이프라인을 비운다.
  
- 하드웨어 메모리 모델
    - 어떻게 하면 서로 다른 여러 CPU가 일관되게 동일한 메모리 주소를 액세스 할 수 있을까?
    - 하드웨어에 따라 다르지만, JIT 컴파일러(javac)와 CPU는 일반적으로 코드 실행 순서를 바꿀 수 있다. (물론 결과는 아무런 영향이 없다는 전제)

### 3.4 운영체제

스케줄러

- 프로세스 스케줄러는 CPU 엑세스를 통제한다. 실행 큐를 이용한다.
- 스케줄러는 인터럽트에 응답하고 CPU 코어 액세스를 관리한다.

컨텍스트 교환

- OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 스레드/태스크로 대체하는 프로세스
- 컨텍스트 교환은 비싼 작업이다. 특히 유저에서 커널모드가 비싼데 이는 명령어와 다른 캐시를 어쩔 수 없이 비워야하기 때문이다.
- 유저공간에 있는 코드가 액세스하는 메모리 영역은 커널 코드와 거의 공유할 부분이 없기 때문
- 리눅스는 이를 만회하기 위해 가상 동적 공유 객체라는 장치를 제공한다.
- vDOS는 굳이 커널 프리빌리지가 필요 없는 시스템 콜의 속도를 높히려고 쓰는 유저 공간의 메모리 영역
- 커널모드로 컨텍스트를 교환하지 않으니 속도가 빠르다.

### 3.6 기본 감지 전략

- CPU 사용률
    - 부하가 집중도닌 도중에는 유저 공간의 CPU 사용률이 100% 가깝게 유지해야한다.
- 가비지 수집
  - 핫스팟 JVM은 시작시 메모리를 유저 공간에 할당/관리한다. 따라서 메모리 할당하느라 시스템 콜을 할 필요가 없다.
- 입출력

vmstat과 iostat  
- 유닉스계열 OS에서 각각 현재 가상 메모리 및 I/O 서브시스템 상태에 관한 유용한 데이터를 신속히 제공한다.  

- vmstat 섹션
  - proc 섹션: 실행 가능한 프로세스(r), 블로킹(b)된 프로세스 개수
  - memory 섹션: 스왑메모리(swpd), 미사용 메모리(free), 버퍼로 사용한 메모리(buff), 캐시로 사용한 메모리 표시(cache)
  - swap 섹션: 디스크로 교체되어 들어간 메모리(si), 디스크에서 교체되어 빠져나온 메모리 정보(so)
  - io 섹션: 블록-인(bi), 블록-아웃(bo) 개수는 각각 블록 장치에서 받은 512바이트 블록, 블록 장치로 보낸 512바이트 블록 개수
  - system 섹션: 인터럽트(in) 및 초당 컨텍스트 교환(cs) 횟수
  - cpu 섹션: CPU와 직접 연관된 지표를 CPU 사용률로 표기. 좌측부터 유저시간(us), 커널시간(sy), 유휴시간(id), 대기시간(wa), 도둑맞은 시간(st)이다.

### 3.7 가상화

- 기본적으로 호스트OS위에 게스트OS가 있는 방식이다.
- 가상화 시스템에서는 게스트 OS가 하드웨어에 직접 액세스 할 수 없다.

### 3.8 JVM과 운영체제

- JVM은 자바 코드에 공용 인터페이스를 제공하여  OS에 독립적인 휴대용 실행환경을 제공
- 하지만 스레드 스케줄링(시스템 클록에서 시간 정보를 얻는 간단한 작업)도 하부 OS에 반드시 액세스 해야한다.
- 이런 기능은 네이티브 메서드로 구현하며 이 작업을 대행하는 공통 인터페이스를 JNI라고 한다.
- 네이티브 메서드는 C언어로 작성하지만, 다른 자바 메서드 처럼 엑세스 할 수 있다.
- System.currentTimeMills() → JVM_CurrentTimeMills() → os::javaTimeMillis() 순으로 호출된다.
