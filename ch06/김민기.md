# Chapter6. 가비지 수집 기초

자바 가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하며 쓸모없는 객체를 알아서 제거하는 것이다. 이렇게 자동 회수한 메모리는 깨끗이 비우고 재활용할 수 있다.

모든 가비지 수집 구현체는 두 가지 기본원칙을 준수해야 한다.

1. 알고리즘은 반드시 모든 가비지를 수집해야 한다
1. 살아 있는 개체는 절대로 수집해선 안된다

2번 원칙이 더 중요하다. 살아 있는 객체를 수집했다간 세그먼테이션 결함이 발생하거나 프로그램 데이터가 더럽혀 진다.

프로그래머가 저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사상이 자바 관리 방식의 핵심으로 블루칼라 언어라고 말한 특징이 잘 드러나느 대목이다.

## 1. 마크 앤 스위프

가비지 수집이 뭐냐고 물어보면 대부분 마크 앤 스위프(표시하고 쓸어 담기) 알고리즘이 기초라는 정도는 알지만, 실제로 그 프로세스가 어떻게 작동하는지 자세히 모르는 사람들이 많다.

가장 초보적인 마크 앤 스위프 알고리즘은 할당됐지만, 아직 회수되지 않은 객체를 가리키는 포인터를 포함한 할당 리스트(allocated list)를 사용한다. 전체적인 GC알고리즘은 다음과 같다.

![markandswift.png](../images/markandswift.png)

1. 할당 리스트를 순회하면서 마크 비트를 지운다
1. GC루트부터 살아 있는 객체를 찾는다.
1. 이렇게 찾은 객체마다 마크 비트를 세팅한다
1. 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾는다

살아있는 객체는 대부분 DFS방식으로 찾으며, 이렇게 생성된 객체 그래프를 라이브 객체 그래프(live object graph)라고 하며, 접근 가능한 객체의 전이 폐쇄(transitive closure of reachable objects)라고도 한다.

### 1.1 가비지 수집 용어

GC 알고리즘의 용어를 알아보자

- **STW(Stop the world)** : GC사이클이 발생하여 가비지를 수집하는 동안에는 모든 애플리케이션 스레드가 중단된다. 따라서 애플리케이션 코드는 GC스레드가 바라보는 힙 상태를 무효화할 수 없다.
- **동시** : GC스레드는 애플리케이션 스레드와 동시(병행) 실행될 수 있다. 이는 계산 비용 면에서 매우 어렵고 비싼 작업인 데다, 100% 동시 실행을 보장하는 알고리즘은 없다.
- **병렬** : 여러 스레드를 동원해서 가비지를 수집한다
- **정확** : 보수적인 스킴은 정확한 스킴의 정보가 없다. 리소스를 낭비하는 일이 잦고 근본적으로 타입 체계를 무시하기 때문에 비효율적이다
- **이동** : 이동 수집기에서 객체는 메모리를 여기저기 오갈 수 있다. 객체 주소가 고정된게 아니다.
- **압착** : 할당된 메모리는 GC 사이클 마지막에 연속된 단일 영역으로 배열되며, 객체 쓰기가 가능한 여백의 시작점을 가리키는 포인터가 있다. 압착 수집기는 메모리 단편화를 방지한다.
- **방출** : 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 이동한다

## 2. 핫스팟 런타임 개요

GC뿐 아니라, 구현체에 특정한 용어도 있다. GC의 작동 원리를 온전히 이해하려면 핫스팟 내부도 알아야 한다.

자바언어에서는 두 가지 값만 사용한다.

- 기본형 (byte, int)
- 객체 레퍼런스

많은 자바 프로그래머들이 **객체**를 뭉뚱그려 말하는데 자바는 C++과 달리 주소를 역참조하는 메커니즘이 없고 오직 **오프셋 연산자**만으로 필드에 액세스하거나 **객체 레퍼런스**의 메서드를 호출할 수 있다. 또 자바는 값으로 호출 방식으로만 메서드를 호출한다.

### 2.1 객체를 런타임에 표현하는 방법

핫스팟은 런타임에 oop라는 구조체(structure)로 자바 객체를 나타낸다. **oop**는 **평범한 객체 포인터(ordinary object pointer)**의 줄임말로 C언어 느낌의 순수 포인터다. oop는 참조형 지역 변수안에 위치하며 자바 메서드의 스택 프레임으로부터 자바 힙을 구성하는 메모리 영역 내부를 가리킨다. oop를 구성하는 자료 구조는 여러가지 인데, 그중 instanceOop는 자바 클래스의 인스턴스를 나타낸다.

instanceOop의 메모리 레이아웃은 모든 객체에 대해 기계어 워드 2개로 구성된 헤더로 시작한다. Mark 워드(인스턴스 관련 메타데이터를 가리키는 포인터)가 먼저 나오고, 그다음 Klass 워드(클래스 메타데이터를 가리키는 포인터)가 나온다.

<aside>
💡 Mark 워드 : 객체의 메타데이터를 저장하는 영역, 주로 객체의 상태, 동기화 정보, GC 관련 정보를 포함, 객체의 락 상태 등을 나타내는 비트들이 여기에 저장됨
Klass 워드 : 객체의 클래스 정보를 나타내는 포인터, 객체가 어떤 클래스의 인스턴스인지 알려주는 역할, 클래스 정보는 해당 클래스의 메소드, 인스턴스 변수등에 대한 참조를 포함

</aside>

이전 7버전까지는 메모리 레이아웃은 Klass 워드가 자바 힙의 일부인 펌젠(perm gen)이라는 메모리 영역을 가리켰다. 8부터는 Klass가 자바 힙의 주 영역 밖으로 빠지게 됐다(Meta space로 변경). 그래서 객체 헤더가 필요 없어졌다.

![memory.png](../images/memory.png)

oop는 대부분 기계어 워드라 이전엔 32비트, 요즘은 64비트다. 64비트가 되면서 메모리를 절약할 수 있게 압축 oop라는 기법을 옵션으로 제공하며, 7버전 이상,64비트 힙에서 디폴트로 적용되어 있다.

압축 oop의 대상

- 힙에 있는 모든 객체의 Klass 워드
- 참조형 인스턴스 필드
- 객체 배열의 각 원소

핫스팟 객체 헤더

- Mark 워드 (32비트 환경은 4바이트, 64비트 환경은 8바이트)
- Klass 워드(압축됐을 수 있음)
- 객체가 배열이면 length 워드 (항상 32비트)
- 32비트 여백(정렬 규칙 때문에 필요할 경우)

객체 인스턴스 필드는 헤더 바로 다음에 나열된다. klassOop는 klass 워드 다음에 메서드 vtable이 나온다.

![instance_vtable.png](../images/instance_vtable.png)

자바에서 배열은 객체다. JVM 배열도 oop로 표시되며 배열은 Mark 워드, Klass 워드 다음에 배열 길이를 나타내는 Length 워드가 붙는다. 자바 배열 인덱스가 32비트 값으로 제한되는 건 이 때문이다.

JVM환경에서 자바 레퍼런스는 intanceOop(또는 null)를 제외한 어떤 것도 가리킬 수 없다.

- 자바 값은 기본형 값 또는 instanceOop 주소에 대응되는 비트 패턴이다.
- 모든 자바 레퍼런스는 자바 힙의 주 영역에 있는 주소를 가리키는 포인터라고 볼 수 있다
- 자바 레퍼런스가 가리키는 주소에는 Mark 워드 + Klass 워드가 들어 있다
- KlassOop와 Class<?> 인스턴스는 다르며, klassOop을 자바 변수안에 넣을 수 없다.

핫스팟의 oop 체계는 OpenJDK 8 기준 hotspot/src/share/vm/oops 디렉터리에 있는 .hpp 파일에 정의돼 있다.

oop의 전체 상속 구조

- oop (추상 베이스)

이렇게 런타임에 oop 구조체를 이용해서 한 포인터는 클래스 메타데이터를 다른 포인터는 인스턴스 메타데이터를 가리켜 객체를 나타내는 건 드문 방식이 아니다. 다른 JVM이나 실행환경(ex: iOS)도 유사한 메커니즘이다.

### 2.2 GC 루트 및 아레나

GC 루트는 메모리의 고정점(앵커포인트 anchor point)로, 메모리 풀 외부에서 내부를 가리키는 포인터다. 메모리 풀 내부에서 같은 메모리 풀 내부의 다른 메모리 위치를 가리키는 내부 포인터와 정반대 외부 포인터가 있다.

GC 루트의 종류

- 스택 프레임 stack frame
- JNI
- 레지스터(hoisted 끌어올려진 변수)
- (JVM코드 캐시에서)코드 루트
- 전역 객체
- 로드된 클래스의 메타데이터

힙에 있는 객체를 가리키는 (null 아닌) 참조형 지역 변수도 말하자면 가장 단순한 형태의 GC 루트다.  핫스팟 GC는 아레나(무대 arena)라는 메모리 영역에서 작동하며 자바 힙을 관리할 때 시스템 콜을 하지 않는다.

## 3. 할당과 수명

가비지 수집이 일어나는 주된 원인은 두가지 경우이다.

- 할당률 : 일정 기간(MB/s) 새로 생성된 객체가 사용한 메모리량
- 객체 수명 : 대부분 측정하기 어려우며 수동 메모리 관리 시스템은 객체 수명을 제대로 파악하기 너무 복잡하다는 것이다. 그 결과 객체 수명이 할당률보다 더 핵심적인 요인이다.

### 3.1 약한 세대별 가설

소프트웨어 시스템의 런타임 작용을 관찰한 결과 알게된 경험 지식으로 JVM 메모리 관리의 이론적 근간을 형성한다.

> JVM 및 유사 소프트웨어 시스템에서 객체 수명은 이원적 분포 양상을 보인다. 거의 대부분의 객체는 아주 짧은 시간만 살아 있지만, 나머지 객체는 기대 수명이 훨씬 길다.
>

객체 지향 워크로드를 상대로 실제 실험을 하며 얻은 것으로 결론은 ‘가비지를 수집하는 힙은 단명 객체를 쉽고 빠르게 수집할 수 있게 설계해야 하며, 장수 객체와 단명 객체를 완전히 떼어놓는 게 가장 좋다’는 것이다.

- 객체마다 ‘세대 카운트 generational count(객체가 지금까지 무사 통과한 가비지 수집 횟수)’를 센다
- 큰 객체를 제외한 나머지 객체는 에덴 공간에 생성한다. 여기서 살아남은 객체는 다른 곳으로 옮긴다.
- 장수했다고 할 정도로 오래 살아남은 객체들은 별도의 메모리 영역(Old, Tenured 세대)에 보관한다.

세대별 수집 목적에 따라 메모리를 상이한 영역으로 나누면 핫스팟의 마크 앤 스위프 수집의 구현에 따라서 그 결과가 더 세분화된다. 여기서 중요한건 외부에서 영 세대 내부를 가리키는 포인터를 계속 추적하는 기법이다. 덕분에 살아남은 젋은 객체들을 다 추적할 필요가 없다.

핫스팟은 카드 테이블이라는 자료 구조에 늙은 객체가 젋은 객체를 참조하는 정보를 기록한다. 카드 테이블은 JVM이 관리하는 바이트 배열로 각 원소는 올드 세대 공간의 512바이트 영역을 가리킨다.

핵심 로직은 늙은 객체 o에 있는 참조형 필드값이 바뀌면 o에 해당하는 instanceOop가 들어 있는 카드를 찾아 해당 엔트리를 더티 마킹한다. 핫스팟은 레퍼런스 필드를 업데이트할 때마다 단순 쓰기 배리어를 이용한다.

```java
cards[*instanceOop >> 9] = 0;
```

자바 수집기는 이전부터 힙을 영/올드 영역으로 나눠 관리했는데 자바 8u40 버전부터 새로운 수집기(Garbage First, G1)의 품질이 완성 단계에 이르렀다.

## 4. 핫스팟의 가비지 수집

자바는 OS를 이용해 동적으로 메모리를 관리하지 않는다. 대신 일단 프로세스가 시작되면 JVM은 메모리를 할당하고 유저 공간에서 연속된 단일 메모리 풀을 관리한다. 이 메모리 풀은 각자의 목적에 따라 서로 다른 영역으로 구성되며 객체는 보통 에덴 영역에 생성된다. 수집기가 줄곧 객체를 이동시키기 때문에 객체가 차지한 주소는 대부분 시간이 흐르면서 변한다. 이처럼 객체를 이동시키는 것을 ‘방출’이라고 하며 핫스팟 수집기는 대부분 방출 수집기다.

### 4.1 스레드 로컬 할당

JVM은 성능을 강화하여 에덴을 관리한다. 에덴은 대부분의 객체가 탄생하는 장소이고 단명 객체는 다른곳에서 위치할 수 없으므로 특별히 관리를 잘해야하는 영역이다.

JVM은 에덴 여러 버퍼로 나눠 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포한다. 다른 스레드가 자신의 버퍼에 객체를 할당하지 않을까 하는 염려할 필요가 없다. 이 구역을 스레드 로컬 할당 버퍼라고 한다. (Thread-Local Allocation Buffer)

<aside>
💡 핫스팟은 애플리케이션 스레드에 발급한 TLAB 크기를 동적으로 조정한다. 스레드가 메모리를 엄청 소모하고 있으면 스레드에 버퍼를 내주는 오버헤드를 줄이기 위해 더 큰 TLAB를 건네준다.

</aside>

애플리케이션 스레드가 자신의 TLAB를 배타적으로 제어한다는 건 JVM 스레드의 할당 복잡도가 O(1)이라는 것이다. 스레드가 객체를 생성할 때 이 객체에 저장 공간이 할당되고 스레드-로컬 포인터는 그다음 비어 있는 메모리 주소를 가리키도록 업데이트하기 때문이다.

아래 그림을 보면 각 애플리케이션 스레드가 새 객체를 할당할 버퍼를 갖고 있다. 애플리케이션 스레드가 버퍼를 다 채우면 JVM은 새 에덴 영역을 가리키는 포인터를 내어준다.

![thread-local.png](../images/thread-local.png)

### 4.2 반구형 수집

반구형(방출) 수집기는 보통 크기가 같은 두 공간을 사용하는 독특한 방출 수집기로 실제 장수하지 못한 객체를 임시 수용소에 담아 두자는 아이디어다. 덕분에 단명 객체가 테뉴어드 세대를 어지럽히지 않게 하고 풀GC 발생 빈도를 줄일 수 있다.

- 수집기가 라이브 반구를 수집할 때 객체들은 다른 반구로 압착시켜 옮기고 수집된 반구는 비워서 재사용한다
- 전반의 공간은 항상 완전히 비운다

핫스팟에서는 영 힙의 반구부를 서바이버(survivor 생존자)공간이라고 한다 이 공간은 에덴보다 작으며, 역할은 각 영세대 수집을 교환하는 것이다.

## 5. 병렬 수집기

자바 8 이전까지 JVM 기본 가비지 수집기는 병렬 수집기였다. 처리율에 최적화되어 있고, 영 GC, 풀 GC 모두 STW를 일으킨다. 애플리케이션 스레드를 모두 중단시킨 다음 가용 CPU 코어를 총동원해 가능한 한 빨리 메모리를 수집한다.

- Parallel GC : 가장 단순한 영 세대용 병렬 수집기
- ParNew GC : CMS 수집기와 함께 사용할 수 있게 Parallel GC를 조금 변형함
- ParallelOld GC : 올드 세대용 병렬 수집기

### 5.1 영 새대 병렬 수집

가장 흔한 가비지 수집 형태로 스레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB공간은 부족하고 JVM은 새 TLAB를 할당할 수 없을 때 영 세대 수집이 발생한다. 영 세대 수집이 일어나면 JVM은 어쩔수 없이 전체 애플리케이션 스레드를 중단시킨다.

중단되면 핫스팟은 영 세대(에덴 및 현재 비어 있지 않은 서바이버 공간)을 뒤져서 가비지가 아닌 객체를 골라낸다. 이때 GC 루트(와 올드 세대에서 출발하는 GC 루트를 식별하기 위한 카드 테이블)를 병렬 마킹 스캔 작업의 출발점으로 삼는다. 그후 Parallel GC는 살아남은 객체를 현재 비어있는 서바이버 공간으로 모두 방출한 뒤 세대 카운트를 늘려 한 차례 이동했음을 기록한다. 마지막으로 에덴과 이제 막 객체들을 방출시킨 서바이버 공간을 재사용 가능한 공간으로 표시하고 애플리케이션 스레드를 재시작해 TLAB를 애플리케이션 스레드에 배포하는 프로세스를 재개한다.

### 5.2 올드 세대 병렬 수집

자바 8버전 기준 기본 올드 세대 수집기로 Parallel GC와 상당히 비슷하지만 근본적인 차이점으로 Parallel GC는 객체를 방출하는 반구형 수집기지만, ParallelOld GC는 하나의 연속된 메모리 공간에서 압착하는 수집기다.

올드 세대에 더 이상 방출한 공간이 없으면 병렬 수집기는 올드 세대 내부에서 객체들을 재배치해서 늙은 객체가 죽고 빠져 버려진 공간을 회수하려고 한다. 풀 GC 사이클 내내 CPU를 점유하는 대가로 메모리는 아주 효율적으로 배치된다.

영 세대 수집은 단명 객체 처리가 목적이기 때문에 영 공간의 점유 상태는 GC 이벤트가 발생할 때마다 메모리 할당 및 소거가 일어나면서 급격히 변한다.

올드 공간은 크게 눈에 띄는 변화가 없다. 가끔 큰 객체가 테뉴어드 세대에 직접 생성될 때도 있지만, 그밖에는 영 세대 객체가 승격되거나 올드/풀 수집이 일어나 객체를 재탐색 후 다시 배치하는 등의 수집이 일어날 때만 변한다

### 5.3 병렬 수집기의 한계

세대 전체 콘텐츠를 대상으로 한번에, 가능한 한 효율적으로 가비지를 수집한다. 하지만 이 방식도 단점이 있다.

먼저 풀 STW를 유발한다. 약한 세대별 가설에 따르면 극소수 객체만 남기 때문에 영 수집에서는 STW가 문제되진 않는다.

전체 힙에서 영 영역을 작게 구성한 설계는 기본적으로 대부분의 워크로드에서 영 수집에 따른 중단 시간이 매우 짧다고 가정한 것이다. 그러나 올드 수집은 사정이 다르다. 디폴프 크기 자체가 영 세대의 7배나되며, 이것 하나만으로 풀 수집 시 STW시간이 영 수집보다 훨씬 길다. 또 하나 중요한 사실은 영역 내 살아있는 개체 수만큼 마킹 시간도 늘어난다는 것이다. 올드 객체는 장수한 객체이므로 풀 수집 시 이들중 상당수는 살아남는다.

올드 수집의 큰 약점은 STW 시간이 힙 크기에 거의 비례한다는 점이다. 힙이 계속 커질수록 ParallelOld GC의 중단 시간도 함께 나빠진다.

## 6. 할당의 역할

자바의 가비지 수집 프로세스는 보통 유입된 메모리 할당 요청을 수용하기에 메모리가 부족할 때 작동하여 필요한 만큼 메모리를 공급한다. 즉 GC 사이클은 어떤 고정된, 예측 가능한 일정에 맞춰 발생하는 게 아니라 그때끄때 필요에 의해 발생한다.

이렇게 불확정적으로, 불규칙하게 발생하는 점이 가비지 수집의 가장 중요한 특징이다. GC사이클은 하나 이상의 힙 메모리 공간이 꽉 채워져 더 이상 객체를 생성할 공간이 없을 때 일어난다.

GC가 발생하면 모든 애플리케이션 스레드가 멈춘다. JVM은 모든 코어를 총동원해 가비지를 수집하고 메모리를 회수한 후 , 애플리케이션 스레드를 재개한다.

할당률이 높을수록 GC는 더 자주 발생하며, 할당률이 너무 높으면 객체는 테뉴어드로 곧장 승격된다. 이 현상을 조기 승격이라고 하며, 가비지 수집에서 가장 중요한 간접 효과이자, 많은 튜닝 활동의 출발점 중 하나다.